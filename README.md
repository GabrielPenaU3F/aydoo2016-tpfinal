# aydoo2016-tpfinal

Autor: Gabriel Pena
Revisor: Julian Moreno

Notas:

-Mi solucion no modela los Efectos como objetos, ya que considero que lo importante de los efectos son los n√∫meros que modifica y no su "clasificacion". Decidi no utilizar el patron State porque me parecio que complicaba la legibilidad del codigo innecesariamente, dado que en esta instancia solo son dos estados posibles.
-Realizo la seleccion de efectos para cada colision utilizando metaprogramacion para evitarme recurrir a encadenamientos de if.
-El metodo aplicar_efecto_nulo solo esta codeado como tal por una mera cuestion de facilitar la lectura del codigo. Necesita recibir un parametro para que funcione la implementacion de la colision, pero la realidad es que no hace nada. Igual me parecio mejor codearlo asi que hacer, por ejemplo, que "baje la vida en 0".
-En caso de requerir modificaciones, se puede hacer por extension sin violar el Open-Close Principle. Por ejemplo, si se quisiera agregar un nuevo tipo de entidad, bastaria con codearla heredando de la clase EntidadEspacial, agregarle una representacion, y luego heredar de la Colision una version nueva que redefina el metodo "obtener_metodos_y_parametros_correspondientes" agregando las entradas que correspondan a todas las interacciones posibles con la entidad nueva.

Informe de la solucion:
Desde el vamos yo ya tenia en mente un esquema aproximado de mi solucion: sabia que iba a tener las 5 clases del dominio compartiendo una superclase para no repetir codigo, y sabia que iba a tener una clase Colision que manejara lo que ocurria en cada choque. Sabia tambien que cada clase se representaria a si misma con un string y que cada choque estaria representado con un par ordenado (chocante, chocado) que acabo implementado como un string @chocante#chocado. Tambien sabia que las claves de choque con sus respectivos efectos estarian guardados en un hash en algun lado, que termino siendo por varios motivos (comodidad, responsabilidades, extensibilidad) la clase Colision.
El principal problema que tuve fue como implementar los efectos. Tenia que encontrar alguna manera de guardarme en el hash algo que encapsulara comportamiento. Mi primer idea fue, obviamente, tener objetos EfectoDestructivo, Constructivo y Masa con un cierto valor en unidades, que se apliquen a las entidades correspondientes en el choque. El problema con este enfoque era que los efectos yo tenia que crearlos de antemano y tenerlos agregados en el hash, cosa que no podia hacer porque hay muchos efectos que dependen de la vida/masa de las entidades en cuestion al momento del choque, con lo cual esos numeros deberian decidirse al momento del choque y no antes. Una de las formas hubiese sido hacerle llegar al estado la vida y masa de ambos objetos y que calcularan los numeros, pero me parecio que se complicaba demasiado y no estaba muy seguro de como implementarlo. Asi que empece a pensar otras alternativas de como encapsular esos comportamientos y encare por el lado de la metaprogramacion.
La decision final fue dejar de lado los Efectos como objetos, y en su lugar codear simplemente una serie de metodos que le hagan algo a la entidad dado un numero. Como Ruby permite tomar un metodo de un cierto objeto, desvincularlo y vincularlo a otro, guarde en el hash metodos desvinculados y al momento de la colision, a los objetos se les vincula el metodo correspondiente (segun esta especificado en el hash) y se los ejecuta con los numeros correspondientes que se calculan ahi mismo en base a los objetos que chocan (ya que la clase colision los conoce). De esta manera, la clase Colision se encarga de decidir dinamicamente que metodo se ejecutara a cada objeto y con que numeros, y cada objeto se ocupa de modificarse a si mismo para satisfacer lo requerido.

